<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dzieła Bacha – wszystkie utwory</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f5f5f5;
      padding: 20px;
      margin: 0;
    }
    h1 {
      text-align: center;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background: white;
    }
    h2 {
      cursor: pointer;
    }
    .collapsed {
      display: none;
    }
    th, td {
      padding: 8px 12px;
      border: 1px solid #ccc;
    }
    th {
      background-color: #333;
      color: white;
      cursor: pointer;
    }
    tr:nth-child(even) {
      background-color: #f2f2f2;
    }
    .table-wrapper {
      overflow-x: auto;
    }
    #column-toggles {
      margin: 10px 0;
    }
    #column-toggles label {
      margin-right: 10px;
    }
    #map {
      height: 400px;
      margin: 20px 0;
    }
    #filters {
      margin: 10px 0;
    }
    #filters label {
      margin-right: 10px;
    }
    #chart {
      width: 100%;
      height: auto;
    }
    @media (max-width: 600px) {
      body {
        padding: 10px;
      }
      h1 {
        font-size: 1.5em;
      }
      th, td {
        padding: 6px 8px;
        font-size: 0.9em;
      }
    }
  </style>
</head>
<body>
  <h1>Dzieła Johanna Sebastiana Bacha</h1>
  <div id="map"></div>
  <svg id="chart" width="932" height="932"></svg>
  <div id="filters">
    Filtry:
    <label>Miasto:
      <select id="city-filter">
        <option value="">Wszystkie</option>
      </select>
    </label>
    <label>Data od: <input type="number" id="date-from" style="width:6em"></label>
    <label>do: <input type="number" id="date-to" style="width:6em"></label>
  </div>
  <div id="column-toggles">
    Pokaż kolumny:
    <label><input type="checkbox" data-col="1"> BC</label>
    <label><input type="checkbox" data-col="3"> Tonacja</label>
    <label><input type="checkbox" data-col="4"> Data</label>
    <label><input type="checkbox" data-col="5"> Miasto</label>
    <label><input type="checkbox" data-col="6"> Gatunek</label>
    <label><input type="checkbox" data-col="7"> Obsada</label>
    <label><input type="checkbox" data-col="8"> Uwagi</label>
    <label><input type="checkbox" data-col="9"> Tekst</label>
    <label><input type="checkbox" data-col="10"> Video</label>
  </div>
  <div id="works"></div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script>
    const categories = [
      { name: 'Kantaty', start: 1, end: 224 },
      { name: 'Motety', start: 225, end: 231 },
      { name: 'Msze i Magnificaty', start: 232, end: 243 },
      { name: 'Pasje i oratoria', start: 244, end: 249 },
      { name: 'Czterogłosowe chorały', start: 250, end: 438 },
      { name: 'Pieśni i arie', start: 439, end: 518 },
      { name: 'Pieśni sakralne', start: 519, end: 523 },
      { name: 'Quodlibet', start: 524, end: 524 },
      { name: 'Sonaty', start: 525, end: 530 },
      { name: 'Preludia, toccaty, fugi, fantazje, passacaglie', start: 531, end: 582 },
      { name: 'Tria', start: 583, end: 586 },
      { name: 'Różne utwory', start: 587, end: 591 },
      { name: 'Koncerty', start: 592, end: 597 },
      { name: 'Ćwiczenia pedałowe', start: 598, end: 598 },
      { name: 'Preludia chorałowe', start: 599, end: 765 },
      { name: 'Partity i wariacje chorałowe', start: 766, end: 771 },
      { name: 'Inwencje', start: 772, end: 786 },
      { name: 'Sinfonie', start: 787, end: 801 },
      { name: 'Duety', start: 802, end: 805 },
      { name: 'Suity angielskie', start: 806, end: 811 },
      { name: 'Suity francuskie', start: 812, end: 817 },
      { name: 'Różne suity', start: 818, end: 824 },
      { name: 'Partity', start: 825, end: 830 },
      { name: 'Uwertury i suity', start: 831, end: 845 },
      { name: 'Preludia, fugi, fantazje, toccaty', start: 846, end: 920 },
      { name: 'Preludia', start: 921, end: 943 },
      { name: 'Fugi i fughetty', start: 944, end: 962 },
      { name: 'Sonaty i części sonat', start: 963, end: 970 },
      { name: 'Koncerty (klawiszowe)', start: 971, end: 987 },
      { name: 'Wariacje i różne utwory', start: 988, end: 994 },
      { name: 'Na instrument solo', start: 995, end: 1013 },
      { name: 'Na dwa lub więcej instrumentów', start: 1014, end: 1040 },
      { name: 'Koncerty (orkiestrowe)', start: 1041, end: 1065 },
      { name: 'Uwertury i suity (orkiestrowe)', start: 1066, end: 1070 },
      { name: 'Kanony', start: 1072, end: 1078 },
      { name: 'Późne utwory kontrapunktyczne', start: 1079, end: 1080 },
      { name: 'Nowsze dodatki do BWV', start: 1081, end: 1177 },
    { name: 'Utwory fragmentaryczne, zaginione, wątpliwe i fałszywe', prefix: 'Anh.' }
  ];

  function normalizeBwv(value) {
    const anh = value.match(/^Anh\.(\d+)/i);
    if (anh) {
      return 'Anh.' + String(parseInt(anh[1], 10));
    }
    if (/^\d+$/.test(value)) {
      return String(parseInt(value, 10));
    }
    return value.trim();
  }

  function makeSortable(table) {
    const headers = table.querySelectorAll('th');
    headers.forEach((th, index) => {
      let asc = true;
      th.addEventListener('click', () => {
        const tbody = table.tBodies[0];
        const rows = Array.from(tbody.querySelectorAll('tr'));
        rows.sort((a, b) => {
          const A = a.children[index].textContent.trim();
          const B = b.children[index].textContent.trim();
          const numA = parseFloat(A);
          const numB = parseFloat(B);
          if (!isNaN(numA) && !isNaN(numB)) {
            return asc ? numA - numB : numB - numA;
          }
          return asc ? A.localeCompare(B) : B.localeCompare(A);
        });
        asc = !asc;
        rows.forEach(r => tbody.appendChild(r));
      });
    });
  }

  function updateColumnVisibility() {
    document.querySelectorAll('#column-toggles input').forEach(cb => {
      const index = parseInt(cb.dataset.col, 10) + 1;
      const display = cb.checked ? '' : 'none';
      document.querySelectorAll(`#works table`).forEach(table => {
        table.querySelectorAll(`th:nth-child(${index}), td:nth-child(${index})`).forEach(cell => {
          cell.style.display = display;
        });
      });
    });
  }

  document.querySelectorAll('#column-toggles input').forEach(cb => {
    cb.addEventListener('change', updateColumnVisibility);
  });
  function applyFilters() {
    const city = document.getElementById('city-filter').value;
    const from = parseInt(document.getElementById('date-from').value, 10);
    const to = parseInt(document.getElementById('date-to').value, 10);
    document.querySelectorAll('#works tbody tr').forEach(tr => {
      const rowCity = tr.children[5].textContent.trim();
      const dateStr = tr.children[4].textContent.trim();
      const match = dateStr.match(/\d{4}/);
      const year = match ? parseInt(match[0], 10) : null;
      let show = true;
      if (city && rowCity !== city) show = false;
      if (from && (!year || year < from)) show = false;
      if (to && (!year || year > to)) show = false;
      tr.style.display = show ? '' : 'none';
    });
  }

  document.getElementById('city-filter').addEventListener('change', applyFilters);
  document.getElementById('date-from').addEventListener('input', applyFilters);
  document.getElementById('date-to').addEventListener('input', applyFilters);

  function createMap(cities) {
    const cityInfo = {
      'Arnstadt': { coords: [50.836, 10.948], years: '1703–1707' },
      'Köthen': { coords: [51.75, 11.97], years: '1717–1723' },
      'Leipzig': { coords: [51.3397, 12.3731], years: '1723–1750' },
      'Lüneburg': { coords: [53.246, 10.414], years: '1700–1702' },
      'Mühlhausen': { coords: [51.21, 10.452], years: '1707–1708' },
      'Ohrdruf': { coords: [50.82, 10.729], years: '1695–1700' },
      'Weimar': { coords: [50.979, 11.329], years: '1708–1717' }
    };
    const map = L.map('map').setView([51.1657, 10.4515], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '\u00a9 OpenStreetMap'
    }).addTo(map);
    cities.forEach(city => {
      const info = cityInfo[city];
      if (info) {
        const popup = info.years ? `${city}: ${info.years}` : city;
        L.marker(info.coords).addTo(map).bindPopup(popup);
      }
    });
  }

    async function loadData() {
      const works = await fetch('works.json').then(res => res.json());
      const files = ['Bacholoji.csv', 'Bachstiftung.csv', 'Netherlands_Bach_Society.csv'];
      const videoMap = {};
      for (const file of files) {
        try {
          const buffer = await fetch(file).then(res => res.arrayBuffer());
          const bytes = new Uint8Array(buffer);
          let csv;
          if (bytes[0] === 0xff && bytes[1] === 0xfe) {
            csv = new TextDecoder('utf-16le').decode(bytes);
          } else if (bytes[0] === 0xfe && bytes[1] === 0xff) {
            csv = new TextDecoder('utf-16be').decode(bytes);
          } else {
            csv = new TextDecoder('utf-8').decode(bytes);
          }
          csv.split(/\r?\n/).forEach(line => {
            if (!line.trim()) return;
            const [title, id, lengthStr] = line.split(';');
            if (!title || !id) return;
            const match = title.match(/BWV\s*(Anh\.\s*)?(\d+)/i);
            if (!match) return;
            const bwv = normalizeBwv(`${match[1] || ''}${match[2]}`);
            const length = parseFloat(lengthStr) || 0;
            const url = `https://youtu.be/${id.trim()}`;
            if (!videoMap[bwv]) videoMap[bwv] = [];
            videoMap[bwv].push({ url, length, file, title });
          });
        } catch (e) {
          console.warn('Nie można wczytać pliku', file, e);
        }
      }
      const container = document.getElementById('works');
      categories.forEach(cat => {
          const heading = document.createElement('h2');
          heading.textContent = cat.name;
          container.appendChild(heading);

          const table = document.createElement('table');
          const wrapper = document.createElement('div');
          wrapper.classList.add('table-wrapper', 'collapsed');
          wrapper.appendChild(table);
          heading.addEventListener('click', () => {
            wrapper.classList.toggle('collapsed');
          });
          const thead = document.createElement('thead');
          // Kolumna "Miasto" może pozostać pusta, jeśli brak danych o miejscu powstania
          thead.innerHTML = `<tr><th>BWV</th><th>BC</th><th>Tytuł</th><th>Tonacja</th><th>Data</th><th>Miasto</th><th>Gatunek</th><th>Obsada</th><th>Uwagi</th><th>Tekst</th><th>Video</th></tr>`;
          table.appendChild(thead);
          const tbody = document.createElement('tbody');
          table.appendChild(tbody);

          works.filter(row => {
            const bwv = normalizeBwv(row.BWV);
            if (cat.prefix) {
              return bwv.startsWith(cat.prefix);
            }
            const num = parseInt(bwv, 10);
            return !isNaN(num) && num >= cat.start && num <= cat.end;
          }).forEach(row => {
            const tr = document.createElement('tr');
            const bwvNorm = normalizeBwv(row.BWV);
            const entries = (videoMap[bwvNorm] || [])
              .slice()
              .sort((a, b) => b.length - a.length);
            const textUrl = `http://kbpp.org.pl/bwv-${bwvNorm.toLowerCase().replace(/\s+/g, '').replace('.', '-')}`;
            const videoLinks = entries.map(e => {
              const len = e.length ? `${e.length}s` : '';
              const label = e.file.replace('.csv', '');
              return `<a href="${e.url}" target="_blank">${label}: ${e.title}${len ? ` (${len})` : ''}</a>`;
            }).join('<br>');
            tr.innerHTML = `
              <td>${row.BWV}</td>
              <td>${row.BC}</td>
              <td>${row.Title}</td>
              <td>${row.Key}</td>
              <td>${row.Date}</td>
              <td>${row.City || ''}</td>
              <td>${row.Genre}</td>
              <td>${row.Forces}</td>
              <td>${row.Notes}</td>
              <td><a href="${textUrl}" target="_blank">tekst</a></td>
              <td>${videoLinks}</td>
            `;
            tbody.appendChild(tr);
          });

          makeSortable(table);
          container.appendChild(wrapper);
        });
        const cities = [...new Set(works.map(w => w.City).filter(Boolean))].sort();
        const cityFilter = document.getElementById('city-filter');
        cities.forEach(c => {
          const opt = document.createElement('option');
          opt.value = c;
          opt.textContent = c;
          cityFilter.appendChild(opt);
        });
        updateColumnVisibility();
        applyFilters();
        createMap(cities);
      }

  loadData().catch(err => console.error('Błąd wczytywania danych', err));
</script>
<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

const width = 932;
const radius = width / 6;

fetch('liturgical_year.json').then(r => r.json()).then(data => {
  const color = d3.scaleOrdinal(d3.quantize(d3.interpolateRainbow, data.children.length + 1));

  const partition = data => d3.partition()
      .size([2 * Math.PI, radius])
    (d3.hierarchy(data)
      .sum(d => d.children ? 0 : 1)
      .sort((a, b) => b.value - a.value));

  const root = partition(data);
  root.each(d => d.current = d);

  const svg = d3.select('#chart')
      .attr('viewBox', [0, 0, width, width])
      .style('font', '10px sans-serif');

  const g = svg.append('g')
      .attr('transform', `translate(${width / 2},${width / 2})`);

  const arc = d3.arc()
      .startAngle(d => d.x0)
      .endAngle(d => d.x1)
      .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
      .padRadius(radius * 1.5)
      .innerRadius(d => d.y0)
      .outerRadius(d => d.y1 - 1);

  const path = g.append('g')
      .selectAll('path')
      .data(root.descendants().slice(1))
      .join('path')
        .attr('fill', d => { while (d.depth > 1) d = d.parent; return color(d.data.name); })
        .attr('fill-opacity', d => arcVisible(d.current) ? (d.children ? 0.6 : 0.4) : 0)
        .attr('d', d => arc(d.current));

  path.filter(d => d.children)
      .style('cursor', 'pointer')
      .on('click', clicked);

  const label = g.append('g')
      .attr('pointer-events', 'none')
      .attr('text-anchor', 'middle')
      .style('user-select', 'none')
    .selectAll('text')
    .data(root.descendants().slice(1))
    .join('text')
      .attr('dy', '0.35em')
      .attr('fill-opacity', d => +labelVisible(d.current))
      .attr('transform', d => labelTransform(d.current))
      .text(d => d.data.name);

  const parent = g.append('circle')
      .datum(root)
      .attr('r', radius)
      .attr('fill', 'none')
      .attr('pointer-events', 'all')
      .on('click', clicked);

  function clicked(event, p) {
    parent.datum(p.parent || root);

    root.each(d => d.target = {
      x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
      x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
      y0: Math.max(0, d.y0 - p.y0),
      y1: Math.max(0, d.y1 - p.y0)
    });

    const t = g.transition().duration(750);

    path.transition(t)
        .tween('data', d => {
          const i = d3.interpolate(d.current, d.target);
          return t => d.current = i(t);
        })
      .attr('fill-opacity', d => arcVisible(d.target) ? (d.children ? 0.6 : 0.4) : 0)
      .attrTween('d', d => () => arc(d.current));

    label.filter(d => labelVisible(d.target))
        .transition(t)
        .attr('fill-opacity', 1)
        .attrTween('transform', d => () => labelTransform(d.current));

    label.filter(d => !labelVisible(d.target))
        .transition(t)
        .attr('fill-opacity', 0);
  }

  function arcVisible(d) {
    return d.y1 <= radius && d.y0 >= 0 && d.x1 > d.x0;
  }

  function labelVisible(d) {
    return d.y1 <= radius && d.y0 >= 0 && (d.x1 - d.x0) > 0.03;
  }

  function labelTransform(d) {
    const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
    const y = (d.y0 + d.y1) / 2;
    return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
  }
});
</script>
</body>
</html>
